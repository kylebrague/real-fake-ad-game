{
  "version": 3,
  "sources": ["../../src/lib/ecs/Entity.ts", "../../src/lib/ecs/World.ts", "../../src/lib/ecs/System.ts", "../../src/lib/ecs/systems/MovementSystem.ts", "../../src/lib/ecs/systems/RenderSystem.ts", "../../src/lib/ecs/systems/CollisionSystem.ts", "../../src/lib/ecs/components/CoreComponents.ts", "../../src/lib/ecs/components/GameComponents.ts", "../../src/lib/ecs/systems/PlayerSystem.ts", "../../src/lib/ecs/systems/SpawnSystem.ts", "../../src/lib/ecs/systems/CleanupSystem.ts", "../../src/lib/ecs/systems/PowerupSystem.ts", "../../src/lib/ecs/utils/BackgroundFactory.ts", "../../src/lib/ecs/Game.ts", "../../src/index.ts"],
  "sourcesContent": ["/**\n * Entity in the ECS architecture\n * \n * In ECS, entities are just unique identifiers that components are attached to.\n * They have no behavior or data themselves - they're simply a way to group components.\n */\nexport class Entity {\n  private static nextId = 0;\n  readonly id: number;\n\n  constructor() {\n    this.id = Entity.nextId++;\n  }\n\n  /**\n   * Check if this entity is the same as another\n   */\n  equals(other: Entity): boolean {\n    return this.id === other.id;\n  }\n}", "import type { Component } from './Component';\nimport { Entity } from './Entity';\nimport type { System } from './System';\n\n/**\n * World class for the ECS architecture\n * \n * The World manages all entities, components and systems.\n * It provides methods for creating entities, adding components,\n * querying entities with specific components, and updating systems.\n */\nexport class World {\n  private entities: Entity[] = [];\n  private components: Map<number, Map<string, Component>> = new Map();\n  private systems: System[] = [];\n  private entityComponentCache: Map<string, Entity[]> = new Map();\n  private cacheValid = false;\n\n  /**\n   * Create a new entity\n   */\n  createEntity(): Entity {\n    const entity = new Entity();\n    this.entities.push(entity);\n    this.components.set(entity.id, new Map());\n    this.cacheValid = false;\n    return entity;\n  }\n\n  /**\n   * Remove an entity and all its components\n   */\n  removeEntity(entity: Entity): void {\n    const index = this.entities.findIndex(e => e.equals(entity));\n    if (index !== -1) {\n      this.entities.splice(index, 1);\n      this.components.delete(entity.id);\n      this.cacheValid = false;\n    }\n  }\n\n  /**\n   * Add a component to an entity\n   */\n  addComponent(entity: Entity, component: Component): void {\n    const entityComponents = this.components.get(entity.id);\n    if (entityComponents) {\n      entityComponents.set(component.type, component);\n      this.cacheValid = false;\n    }\n  }\n\n  /**\n   * Get a component from an entity\n   */\n  getComponent<T extends Component>(entity: Entity, componentType: string): T | undefined {\n    const entityComponents = this.components.get(entity.id);\n    if (entityComponents) {\n      return entityComponents.get(componentType) as T | undefined;\n    }\n    return undefined;\n  }\n\n  /**\n   * Remove a component from an entity\n   */\n  removeComponent(entity: Entity, componentType: string): void {\n    const entityComponents = this.components.get(entity.id);\n    if (entityComponents) {\n      entityComponents.delete(componentType);\n      this.cacheValid = false;\n    }\n  }\n\n  /**\n   * Add a system to the world\n   */\n  addSystem(system: System): void {\n    this.systems.push(system);\n    system.setWorld(this);\n    system.initialize();\n  }\n\n  /**\n   * Get systems by their class name\n   * This allows other systems to find specific system instances\n   */\n  getSystems(systemName: string): System[] {\n    return this.systems.filter(system => {\n      const className = system.constructor.name;\n      return className === systemName;\n    });\n  }\n\n  /**\n   * Get all entities that have the specified component types\n   */\n  getEntitiesWith(...componentTypes: string[]): Entity[] {\n    const cacheKey = componentTypes.sort().join(',');\n    \n    if (!this.cacheValid) {\n      this.refreshCache();\n    }\n    \n    if (!this.entityComponentCache.has(cacheKey)) {\n      const matchingEntities = this.entities.filter(entity => {\n        const entityComponents = this.components.get(entity.id);\n        if (!entityComponents) return false;\n        \n        return componentTypes.every(type => \n          entityComponents.has(type)\n        );\n      });\n      \n      this.entityComponentCache.set(cacheKey, matchingEntities);\n    }\n    \n    return this.entityComponentCache.get(cacheKey) || [];\n  }\n\n  /**\n   * Refresh the entity component cache\n   */\n  private refreshCache(): void {\n    this.entityComponentCache.clear();\n    this.cacheValid = true;\n  }\n\n  /**\n   * Update all systems\n   */\n  update(deltaTime: number): void {\n    for (const system of this.systems) {\n      system.update(deltaTime);\n    }\n  }\n}", "import type { World } from './World';\n\n/**\n * Abstract System class for the ECS architecture\n * \n * Systems contain the game logic and operate on entities with specific components.\n * Each system focuses on a single aspect of game functionality.\n */\nexport abstract class System {\n  /**\n   * Reference to the world this system belongs to\n   */\n  protected world: World;\n\n  /**\n   * Array of component types that this system operates on\n   */\n  readonly requiredComponents: string[];\n\n  constructor(requiredComponents: string[]) {\n    this.requiredComponents = requiredComponents;\n  }\n\n  /**\n   * Set the world this system belongs to\n   */\n  setWorld(world: World): void {\n    this.world = world;\n  }\n\n  /**\n   * Initialize the system\n   * Called when the system is added to the world\n   */\n  initialize(): void {}\n\n  /**\n   * Update the system\n   * Called every frame with the elapsed time\n   */\n  abstract update(deltaTime: number): void;\n}", "import { System } from '../System';\nimport type { PositionComponent, VelocityComponent } from '../components/CoreComponents';\n\n/**\n * MovementSystem updates entity positions based on their velocities\n */\nexport class MovementSystem extends System {\n  constructor() {\n    // This system operates on entities that have both Position and Velocity components\n    super(['Position', 'Velocity']);\n  }\n\n  update(deltaTime: number): void {\n    // Get all entities with Position and Velocity components\n    const entities = this.world.getEntitiesWith('Position', 'Velocity');\n    \n    // Update the position of each entity based on its velocity\n    for (const entity of entities) {\n      const position = this.world.getComponent<PositionComponent>(entity, 'Position');\n      const velocity = this.world.getComponent<VelocityComponent>(entity, 'Velocity');\n      \n      if (position && velocity) {\n        // Update position based on velocity and delta time\n        position.x += velocity.speedX * deltaTime;\n        position.y += velocity.speedY * deltaTime;\n      }\n    }\n  }\n}", "import { System } from \"../System\";\nimport type {\n  PositionComponent,\n  SizeComponent,\n  RenderComponent,\n  SpriteComponent,\n  BackgroundComponent,\n  PathCommand\n} from \"../components/CoreComponents\";\nimport type { Entity } from \"../Entity\";\n\n/**\n * RenderSystem handles drawing entities to the canvas\n * Supports both basic shape rendering and sprite-based rendering\n */\nexport class RenderSystem extends System {\n  private ctx: CanvasRenderingContext2D;\n  private imageCache: Map<string, HTMLImageElement>;\n\n  constructor(ctx: CanvasRenderingContext2D) {\n    // This system operates on entities with Position and Size components\n    // plus either Render or Sprite components\n    super([\"Position\", \"Size\"]);\n    this.ctx = ctx;\n    this.imageCache = new Map();\n  }\n\n  update(deltaTime: number): void {\n    // First render all background elements\n    const backgroundEntities = this.world.getEntitiesWith(\"Background\");\n    // Sort by z-index to control layering\n    backgroundEntities.sort((a, b) => {\n      const bgA = this.world.getComponent<BackgroundComponent>(a, \"Background\");\n      const bgB = this.world.getComponent<BackgroundComponent>(b, \"Background\");\n      return (bgA?.zIndex || 0) - (bgB?.zIndex || 0);\n    });\n    \n    for (const entity of backgroundEntities) {\n      this.renderBackground(entity);\n    }\n\n    // Get all renderable entities (either basic shapes or sprites)\n    const basicShapeEntities = this.world.getEntitiesWith(\"Position\", \"Size\", \"Render\");\n    const spriteEntities = this.world.getEntitiesWith(\"Position\", \"Size\", \"Sprite\");\n\n    // Then render all basic shapes\n    for (const entity of basicShapeEntities) {\n      this.renderBasicShape(entity);\n    }\n\n    // Finally render all sprites (typically sprites should appear on top of basic shapes)\n    for (const entity of spriteEntities) {\n      this.renderSprite(entity, deltaTime);\n    }\n  }\n\n  /**\n   * Renders a background element\n   */\n  private renderBackground(entity: Entity): void {\n    const background = this.world.getComponent<BackgroundComponent>(entity, \"Background\");\n    \n    if (!background) return;\n    \n    this.ctx.fillStyle = background.color;\n    const path = new Path2D();\n    \n    switch (background.shape) {\n      case 'rectangle':\n        path.rect(background.x, background.y, background.width, background.height);\n        break;\n        \n      case 'polygon':\n      case 'custom':\n        if (background.pathCommands && background.pathCommands.length > 0) {\n          this.executePathCommands(path, background.pathCommands);\n        }\n        break;\n    }\n    \n    this.ctx.fill(path, background.fillRule);\n  }\n  \n  /**\n   * Execute a series of path commands on a Path2D object\n   */\n  private executePathCommands(path: Path2D, commands: PathCommand[]): void {\n    for (const cmd of commands) {\n      switch (cmd.type) {\n        case 'moveTo':\n          path.moveTo(cmd.x, cmd.y);\n          break;\n          \n        case 'lineTo':\n          path.lineTo(cmd.x, cmd.y);\n          break;\n          \n        case 'arc':\n          path.arc(\n            cmd.x, \n            cmd.y, \n            cmd.radius, \n            cmd.startAngle, \n            cmd.endAngle, \n            cmd.counterclockwise\n          );\n          break;\n          \n        case 'arcTo':\n          path.arcTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.radius);\n          break;\n          \n        case 'bezierCurveTo':\n          path.bezierCurveTo(\n            cmd.cp1x, \n            cmd.cp1y, \n            cmd.cp2x, \n            cmd.cp2y, \n            cmd.x, \n            cmd.y\n          );\n          break;\n          \n        case 'quadraticCurveTo':\n          path.quadraticCurveTo(cmd.cpx, cmd.cpy, cmd.x, cmd.y);\n          break;\n          \n        case 'ellipse':\n          path.ellipse(\n            cmd.x, \n            cmd.y, \n            cmd.radiusX, \n            cmd.radiusY, \n            cmd.rotation, \n            cmd.startAngle, \n            cmd.endAngle, \n            cmd.counterclockwise\n          );\n          break;\n          \n        case 'rect':\n          path.rect(cmd.x, cmd.y, cmd.width, cmd.height);\n          break;\n          \n        case 'closePath':\n          path.closePath();\n          break;\n      }\n    }\n  }\n\n  /**\n   * Renders an entity with Position, Size, and Render components\n   */\n  private renderBasicShape(entity: Entity): void {\n    const position = this.world.getComponent<PositionComponent>(entity, \"Position\");\n    const size = this.world.getComponent<SizeComponent>(entity, \"Size\");\n    const render = this.world.getComponent<RenderComponent>(entity, \"Render\");\n\n    if (!position || !size || !render) return;\n\n    this.ctx.fillStyle = render.color;\n    this.ctx.fillRect(position.x, position.y, size.width, size.height);\n  }\n\n  /**\n   * Renders an entity with Position, Size, and Sprite components\n   */\n  private renderSprite(entity: Entity, deltaTime: number): void {\n    const position = this.world.getComponent<PositionComponent>(entity, 'Position');\n    const size = this.world.getComponent<SizeComponent>(entity, 'Size');\n    const sprite = this.world.getComponent<SpriteComponent>(entity, 'Sprite');\n    \n    if (!position || !size || !sprite) return;\n    \n    // Skip rendering if the image is not loaded or has an error\n    if (!sprite.imageElement || !sprite.imageElement.complete || sprite.imageElement.naturalWidth === 0) {\n      return;\n    }\n    \n    // Update animation frame if needed\n    if (sprite.animationSpeed > 0 && sprite.totalFrames > 1) {\n      // Calculate how many frames to advance based on animationSpeed and deltaTime\n      const frameAdvance = sprite.animationSpeed * deltaTime;\n      \n      // Update current frame, handling looping vs non-looping animations\n      if (sprite.loop) {\n        // For looping animations, wrap around to the beginning when reaching the end\n        sprite.currentFrame = (sprite.currentFrame + frameAdvance) % sprite.totalFrames;\n      } else {\n        // For non-looping animations, stop at the last frame\n        sprite.currentFrame = Math.min(sprite.currentFrame + frameAdvance, sprite.totalFrames - 0.001);\n      }\n    }\n    \n    // Save the current context state\n    this.ctx.save();\n    \n    // Apply opacity\n    if (sprite.opacity !== 1) {\n      this.ctx.globalAlpha = Math.max(0, Math.min(1, sprite.opacity));\n    }\n    \n    // Handle rotation by translating to the center of the entity, rotating, then drawing\n    if (position.rotation !== 0) {\n      const centerX = position.x + size.width / 2;\n      const centerY = position.y + size.height / 2;\n      \n      // Move to center, rotate, move back\n      this.ctx.translate(centerX, centerY);\n      this.ctx.rotate(position.rotation);\n      this.ctx.translate(-centerX, -centerY);\n    }\n    \n    // Calculate source rectangle (for sprite sheet frames)\n    const frameWidth = sprite.frameWidth || sprite.imageElement.width;\n    const frameHeight = sprite.frameHeight || sprite.imageElement.height;\n    const currentFrame = Math.floor(sprite.currentFrame); // Get integer frame number\n    \n    // Calculate frame position in the sprite sheet using columns for 2D positioning\n    const columns = sprite.columns || sprite.totalFrames; // Fallback for backward compatibility\n    const sourceX = (currentFrame % columns) * frameWidth;\n    const sourceY = Math.floor(currentFrame / columns) * frameHeight;\n    \n    // Handle horizontal flipping\n    if (sprite.flipped) {\n      this.ctx.translate(position.x + size.width, position.y);\n      this.ctx.scale(-1, 1);\n      this.ctx.drawImage(\n        sprite.imageElement,\n        sourceX, sourceY, frameWidth, frameHeight,\n        0, 0, size.width, size.height\n      );\n    } else {\n      // Normal drawing (no flip)\n      this.ctx.drawImage(\n        sprite.imageElement,\n        sourceX, sourceY, frameWidth, frameHeight,\n        position.x, position.y, size.width, size.height\n      );\n    }\n    \n    // Restore the context to its original state\n    this.ctx.restore();\n  }\n\n  /**\n   * Preloads an image and caches it for future use\n   * Useful for loading assets at startup to avoid delays during gameplay\n   */\n  preloadImage(imageSrc: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      // Check cache first\n      if (this.imageCache.has(imageSrc)) {\n        resolve(this.imageCache.get(imageSrc)!);\n        return;\n      }\n\n      // Create and load new image\n      const image = new Image();\n      image.onload = () => {\n        this.imageCache.set(imageSrc, image);\n        resolve(image);\n      };\n      image.onerror = () => reject(new Error(`Failed to load image: ${imageSrc}`));\n      image.src = imageSrc;\n    });\n  }\n\n  /**\n   * Bulk preload multiple images\n   */\n  preloadImages(imageSrcs: string[]): Promise<HTMLImageElement[]> {\n    return Promise.all(imageSrcs.map((src) => this.preloadImage(src)));\n  }\n}\n", "import type { Entity } from \"../Entity\";\nimport { System } from \"../System\";\nimport {\n  type PositionComponent,\n  type SizeComponent,\n  CollisionComponent,\n  type HealthComponent,\n} from \"../components/CoreComponents\";\nimport type {\n  BulletComponent,\n  EnemyComponent,\n  PowerupComponent,\n  PlayerComponent,\n  GameStateComponent,\n  TagComponent,\n} from \"../components/GameComponents\";\nimport type { PowerupSystem } from \"./PowerupSystem\";\n\n/**\n * CollisionSystem handles collision detection and resolution\n */\nexport class CollisionSystem extends System {\n  private gameHeight: number;\n  private gameWidth: number;\n\n  constructor(canvasWidth: number, canvasHeight: number) {\n    // This system operates on entities with Position, Size, and Collision components\n    super([\"Position\", \"Size\", \"Collision\"]);\n    this.gameWidth = canvasWidth;\n    this.gameHeight = canvasHeight;\n  }\n\n  update(deltaTime: number): void {\n    this.checkBulletCollisions();\n    this.checkPlayerPowerupCollisions();\n    this.checkOffscreenEntities();\n    this.checkEnemyReachedBottom();\n  }\n\n  /**\n   * Check for collisions between bullets and other entities\n   */\n  private checkBulletCollisions(): void {\n    const bullets = this.world.getEntitiesWith(\"Bullet\", \"Position\", \"Size\", \"Collision\");\n    const enemies = this.world.getEntitiesWith(\"Enemy\", \"Position\", \"Size\", \"Collision\", \"Health\");\n    const powerups = this.world.getEntitiesWith(\n      \"Powerup\",\n      \"Position\",\n      \"Size\",\n      \"Collision\",\n      \"Health\"\n    );\n\n    // Check bullet collisions with all collidable entities\n    for (const bulletEntity of bullets) {\n      const bulletComponent = this.world.getComponent<BulletComponent>(bulletEntity, \"Bullet\");\n      if (bulletComponent?.hit) continue;\n\n      const bulletPos = this.world.getComponent<PositionComponent>(bulletEntity, \"Position\");\n      const bulletSize = this.world.getComponent<SizeComponent>(bulletEntity, \"Size\");\n\n      if (!bulletPos || !bulletSize) continue;\n\n      // Check collision with enemies\n      for (const enemyEntity of enemies) {\n        const enemyPos = this.world.getComponent<PositionComponent>(enemyEntity, \"Position\");\n        const enemySize = this.world.getComponent<SizeComponent>(enemyEntity, \"Size\");\n        const enemyHealth = this.world.getComponent<HealthComponent>(enemyEntity, \"Health\");\n\n        if (!enemyPos || !enemySize || !enemyHealth) continue;\n\n        if (this.isColliding(bulletPos, bulletSize, enemyPos, enemySize)) {\n          // Apply bullet damage to enemy\n          enemyHealth.currentHealth -= bulletComponent.damage;\n          bulletComponent.hit = true;\n\n          // Check if enemy was destroyed for scoring\n          if (enemyHealth.currentHealth <= 0) {\n            const enemy = this.world.getComponent<EnemyComponent>(enemyEntity, \"Enemy\");\n            const players = this.world.getEntitiesWith(\"Player\");\n\n            // Add score to player\n            if (enemy && players.length > 0) {\n              const playerComp = this.world.getComponent<PlayerComponent>(players[0], \"Player\");\n              if (playerComp) {\n                playerComp.score += enemy.pointValue;\n              }\n            }\n          }\n          break;\n        }\n      }\n\n      // If bullet didn't hit an enemy, check collision with powerups\n      if (!bulletComponent.hit) {\n        for (const powerupEntity of powerups) {\n          const powerupPos = this.world.getComponent<PositionComponent>(powerupEntity, \"Position\");\n          const powerupSize = this.world.getComponent<SizeComponent>(powerupEntity, \"Size\");\n          const powerupHealth = this.world.getComponent<HealthComponent>(powerupEntity, \"Health\");\n\n          if (!powerupPos || !powerupSize || !powerupHealth) continue;\n\n          if (this.isColliding(bulletPos, bulletSize, powerupPos, powerupSize)) {\n            // Apply bullet damage to powerup\n            powerupHealth.currentHealth -= bulletComponent.damage;\n            // If powerup is destroyed, process its effect\n            if (powerupHealth.currentHealth <= 0) {\n              const powerupSystems = this.world.getSystems(\"PowerupSystem\");\n              if (powerupSystems.length > 0) {\n                const powerupSystem = powerupSystems[0] as PowerupSystem;\n                const players = this.world.getEntitiesWith(\n                  \"Player\",\n                  \"Position\",\n                  \"Size\",\n                  \"Collision\"\n                );\n                for (const playerEntity of players) {\n                  powerupSystem.processPowerup(playerEntity, powerupEntity);\n                }\n              }\n            }\n            bulletComponent.hit = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check for collisions between player and powerups\n   */\n  private checkPlayerPowerupCollisions(): void {\n    const players = this.world.getEntitiesWith(\"Player\", \"Position\", \"Size\", \"Collision\");\n    const powerups = this.world.getEntitiesWith(\"Powerup\", \"Position\", \"Size\", \"Collision\");\n\n    // No players or powerups? Nothing to do\n    if (players.length === 0 || powerups.length === 0) return;\n\n    // Get the player entity (typically just one)\n    const playerEntity = players[0];\n    const playerPos = this.world.getComponent<PositionComponent>(playerEntity, \"Position\");\n    const playerSize = this.world.getComponent<SizeComponent>(playerEntity, \"Size\");\n    const playerHealth = this.world.getComponent<HealthComponent>(playerEntity, \"Health\");\n    if (!playerPos || !playerSize) return;\n\n    // Check each powerup for collision with player\n    for (const powerupEntity of powerups) {\n      const powerupPos = this.world.getComponent<PositionComponent>(powerupEntity, \"Position\");\n      const powerupSize = this.world.getComponent<SizeComponent>(powerupEntity, \"Size\");\n      const powerup = this.world.getComponent<PowerupComponent>(powerupEntity, \"Powerup\");\n      const health = this.world.getComponent<HealthComponent>(powerupEntity, \"Health\");\n\n      if (!powerupPos || !powerupSize || !powerup || !health) continue;\n\n      // Check for collision\n      if (this.isColliding(playerPos, playerSize, powerupPos, powerupSize)) {\n        playerHealth.currentHealth = 0; // powerup runs over player and kills it\n      }\n    }\n  }\n\n  /**\n   * Check if any entities are off screen and mark them for removal\n   */\n  private checkOffscreenEntities(): void {\n    const entities = this.world.getEntitiesWith(\"Position\", \"Size\");\n\n    for (const entity of entities) {\n      const position = this.world.getComponent<PositionComponent>(entity, \"Position\");\n      const size = this.world.getComponent<SizeComponent>(entity, \"Size\");\n\n      if (!position || !size) continue;\n\n      // Check if entity is completely off screen\n      if (\n        position.y > this.gameHeight ||\n        position.y + size.height < 0 ||\n        position.x > this.gameWidth ||\n        position.x + size.width < 0\n      ) {\n        // Mark bullet as hit if it's a bullet\n        const bullet = this.world.getComponent<BulletComponent>(entity, \"Bullet\");\n        if (bullet) {\n          bullet.hit = true;\n        }\n\n        // Remove enemies and powerups if they're off screen\n        const enemy = this.world.getComponent<EnemyComponent>(entity, \"Enemy\");\n        const powerup = this.world.getComponent<PowerupComponent>(entity, \"Powerup\");\n\n        if (enemy || powerup) {\n          const health = this.world.getComponent<HealthComponent>(entity, \"Health\");\n          if (health) {\n            health.currentHealth = 0;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if enemies have reached the bottom of the screen (game over condition)\n   */\n  private checkEnemyReachedBottom(): void {\n    const enemies = this.world.getEntitiesWith(\"Enemy\", \"Position\", \"Size\");\n    const gameState = this.world.getEntitiesWith(\"Tag\");\n\n    let gameStateEntity: Entity;\n    for (const entity of gameState) {\n      const tag = this.world.getComponent<TagComponent>(entity, \"Tag\");\n      if (tag && tag.tag === \"gameState\") {\n        gameStateEntity = entity;\n        break;\n      }\n    }\n\n    if (!gameStateEntity) return;\n    const player = this.world.getEntitiesWith(\"Player\", \"Size\")[0];\n    const playerSize = this.world.getComponent<SizeComponent>(player, \"Size\");\n    for (const enemy of enemies) {\n      const position = this.world.getComponent<PositionComponent>(enemy, \"Position\");\n      const size = this.world.getComponent<SizeComponent>(enemy, \"Size\");\n\n      if (position && size) {\n        if (position.y + size.height - playerSize.height >= this.gameHeight) {\n          // Trigger game over\n          const gameStateComponent = this.world.getComponent<GameStateComponent>(\n            gameStateEntity,\n            \"GameState\"\n          );\n          if (gameStateComponent) {\n            gameStateComponent.isGameOver = true;\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Utility function to check if two entities are colliding\n   */\n  private isColliding(\n    pos1: PositionComponent,\n    size1: SizeComponent,\n    pos2: PositionComponent,\n    size2: SizeComponent\n  ): boolean {\n    return (\n      pos1.x < pos2.x + size2.width &&\n      pos1.x + size1.width > pos2.x &&\n      pos1.y < pos2.y + size2.height &&\n      pos1.y + size1.height > pos2.y\n    );\n  }\n}\n", "import type { Component } from '../Component';\n\n/**\n * Position component\n * Contains the x and y coordinates of an entity\n */\nexport class PositionComponent implements Component {\n  readonly type = 'Position';\n  \n  constructor(\n    public x: number,\n    public y: number,\n    public rotation = 0\n  ) {}\n}\n\n/**\n * Size component\n * Contains the width and height of an entity\n */\nexport class SizeComponent implements Component {\n  readonly type = 'Size';\n  \n  constructor(\n    public width: number,\n    public height: number\n  ) {}\n}\n\n/**\n * Velocity component\n * Contains the speed and direction of an entity\n */\nexport class VelocityComponent implements Component {\n  readonly type = 'Velocity';\n  \n  constructor(\n    public speedX = 0,\n    public speedY = 0\n  ) {}\n}\n\n/**\n * Render component\n * Contains the visual representation data of an entity\n */\nexport class RenderComponent implements Component {\n  readonly type = 'Render';\n  \n  constructor(\n    public color = 'white',\n    public shape: 'rectangle' | 'circle' = 'rectangle'\n  ) {}\n}\n\n/**\n * Sprite component \n * Contains information needed to render an image sprite\n */\nexport class SpriteComponent implements Component {\n  readonly type = 'Sprite';\n  \n  // Image source - can be a path or a loaded HTMLImageElement\n  public imageElement: HTMLImageElement | null = null;\n  private initialFrame: number; // Store the initial frame for animations that need to reset\n\n  constructor(\n    public imageSrc: string,\n    public frameWidth = 0, // If 0, use the entire image\n    public frameHeight = 0, // If 0, use the entire image\n    public currentFrame = 0, // Which frame to start on (0-indexed)\n    public totalFrames = 1, // Total number of frames in the sprite sheet\n    public animationSpeed = 0, // Frames per second, 0 means static image\n    public flipped = false, // Whether to flip the sprite horizontally\n    public opacity = 1, // Transparency (0-1)\n    public loop = true, // Whether animation should loop\n    public columns = 0 // Number of columns in the sprite sheet (0 = single row)\n  ) {\n    // Create and load the image if a source path is provided\n    if (imageSrc) {\n      this.imageElement = new Image();\n      this.imageElement.src = imageSrc;\n    }\n    \n    // Store the initial frame so we can reset the animation\n    this.initialFrame = currentFrame;\n    \n    // Ensure currentFrame is within valid range\n    if (currentFrame >= totalFrames) {\n      this.currentFrame = totalFrames - 1;\n    }\n\n    // If columns is not specified, default to totalFrames (single row)\n    if (this.columns === 0) {\n      this.columns = totalFrames;\n    }\n  }\n  \n  /**\n   * Reset the animation to its initial frame\n   */\n  resetAnimation(): void {\n    this.currentFrame = this.initialFrame;\n  }\n}\n\n/**\n * Health component\n * Contains the health status of an entity\n */\nexport class HealthComponent implements Component {\n  readonly type = 'Health';\n  \n  constructor(\n    public currentHealth: number,\n    public maxHealth: number = currentHealth\n  ) {}\n}\n\n/**\n * Collision component\n * Marks an entity as able to collide\n */\nexport class CollisionComponent implements Component {\n  readonly type = 'Collision';\n  \n  constructor(\n    public collidable = true,\n    public damage = 0,\n    public collisionGroup = 'default'\n  ) {}\n}\n\n/**\n * Background drawing component for rendering static background elements\n * \n * This component allows entities to be rendered as part of the game background\n * with support for rectangles, polygons, and custom paths.\n */\nexport class BackgroundComponent implements Component {\n  readonly type = \"Background\" as const;\n  \n  /**\n   * Create a new background component\n   * \n   * @param shape - The shape type ('rectangle', 'polygon', or 'custom')\n   * @param x - X coordinate of background element (or starting point for paths)\n   * @param y - Y coordinate of background element (or starting point for paths)\n   * @param width - Width of background element (used for rectangle)\n   * @param height - Height of background element (used for rectangle)\n   * @param color - Color of background element (CSS color string)\n   * @param zIndex - Z-index for layering (lower values are drawn first)\n   * @param pathCommands - Array of path commands for polygon or custom paths\n   * @param fillRule - The fill rule to use ('nonzero' or 'evenodd')\n   */\n  constructor(\n    public shape: 'rectangle' | 'polygon' | 'custom' = 'rectangle',\n    public x = 0,\n    public y = 0,\n    public width = 0,\n    public height = 0,\n    public color = \"blue\",\n    public zIndex = 0,\n    public pathCommands: PathCommand[] = [],\n    public fillRule: 'nonzero' | 'evenodd' = 'nonzero'\n  ) {}\n}\n\n/**\n * Types of path commands for Path2D operations\n */\nexport type PathCommand = \n  | { type: 'moveTo', x: number, y: number }\n  | { type: 'lineTo', x: number, y: number }\n  | { type: 'arc', x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean }\n  | { type: 'arcTo', x1: number, y1: number, x2: number, y2: number, radius: number }\n  | { type: 'bezierCurveTo', cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number }\n  | { type: 'quadraticCurveTo', cpx: number, cpy: number, x: number, y: number }\n  | { type: 'ellipse', x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, counterclockwise?: boolean }\n  | { type: 'rect', x: number, y: number, width: number, height: number }\n  | { type: 'closePath' };", "import type { Component } from '../Component';\n\n/**\n * PlayerComponent\n * Marks an entity as the player and stores player-specific data\n */\nexport class PlayerComponent implements Component {\n  readonly type = 'Player';\n  \n  constructor(\n    public lives = 3,\n    public score = 0,\n    public isMovingLeft = false,\n    public isMovingRight = false,\n    public bulletCooldown = 0,       // Current cooldown time remaining\n    public bulletCooldownMax = 0.25  // Time between shots in seconds (4 shots per second)\n  ) {}\n}\n\n/**\n * EnemyComponent\n * Marks an entity as an enemy and stores enemy-specific data\n */\nexport class EnemyComponent implements Component {\n  readonly type = 'Enemy';\n  \n  constructor(\n    public enemyType = 'basic',\n    public pointValue = 10,\n  ) {}\n}\n\n/**\n * PowerupComponent\n * Marks an entity as a powerup and stores powerup-specific data\n */\nexport class PowerupComponent implements Component {\n  readonly type = 'Powerup';\n  \n  constructor(\n    public powerupType: 'basic' | 'rapidFire' | 'superRapidFire' | 'normalizedFire' = 'basic',\n    public value = 1\n  ) {}\n}\n\n/**\n * BulletComponent\n * Marks an entity as a bullet and stores bullet-specific data\n */\nexport class BulletComponent implements Component {\n  readonly type = 'Bullet';\n  \n  constructor(\n    public damage = 1,\n    public hit = false\n  ) {}\n}\n\n/**\n * TagComponent\n * Generic tag component that can be used to mark entities for specific systems\n */\nexport class TagComponent implements Component {\n  readonly type = 'Tag';\n  \n  constructor(\n    public tag: string\n  ) {}\n}\n\n/**\n * GameState component\n */\nexport class GameStateComponent implements Component {\n  readonly type = 'GameState';\n  \n  constructor(\n    public isPaused = false,\n    public isGameOver = false\n  ) {}\n}\n\n/**\n * CooldownModifierComponent\n * Used to apply temporary or permanent modifiers to cooldown systems\n */\nexport class CooldownModifierComponent implements Component {\n  readonly type = 'CooldownModifier';\n  \n  constructor(\n    public bulletCooldownMultiplier = 1.0, // Multiplier for bullet cooldown (< 1 means faster shots)\n    public duration = -1,                  // Duration in seconds (-1 means permanent)\n    public timeRemaining = -1              // Time remaining for temporary effect (-1 means permanent)\n  ) {}\n}", "import type { Entity } from '../Entity';\nimport { System } from '../System';\nimport { \n  PositionComponent, \n  SizeComponent, \n  VelocityComponent,\n  RenderComponent,\n  type HealthComponent,\n  CollisionComponent\n} from '../components/CoreComponents';\nimport { \n  type PlayerComponent, \n  BulletComponent, \n  type CooldownModifierComponent, \n  type GameStateComponent\n} from '../components/GameComponents';\n\n/**\n * PlayerSystem handles player-specific behavior including movement and bullet creation\n * \n * This is a good example of a focused system that handles interactions specific\n * to entities with PlayerComponent\n */\nexport class PlayerSystem extends System {\n  private canvasWidth: number;\n  private canvasHeight: number;\n  private playerSpeed = 400; // pixels per second\n\n  constructor(canvasWidth: number, canvasHeight: number) {\n    super(['Player', 'Position']);\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n  }\n\n  update(deltaTime: number): void {\n    // Get all entities with Player and Position components\n    const playerEntities = this.world.getEntitiesWith('Player', 'Position');\n    \n    // Process each player entity (typically just one in most games)\n    for (const playerEntity of playerEntities) {\n      this.updatePlayerMovement(playerEntity, deltaTime);\n      \n      // Update bullet cooldown timer\n      const player = this.world.getComponent<PlayerComponent>(playerEntity, 'Player');\n      if (player && player.bulletCooldown > 0) {\n        player.bulletCooldown = Math.max(0, player.bulletCooldown - deltaTime);\n      }\n      \n      // Update any active cooldown modifiers\n      this.updateCooldownModifiers(playerEntity, deltaTime);\n    }\n  }\n\n  /**\n   * Updates any active cooldown modifiers on the player\n   */\n  private updateCooldownModifiers(playerEntity: Entity, deltaTime: number): void {\n    const cooldownModifier = this.world.getComponent<CooldownModifierComponent>(\n      playerEntity,\n      'CooldownModifier'\n    );\n    \n    // If there's an active temporary cooldown modifier, update its timer\n    if (cooldownModifier && cooldownModifier.timeRemaining > 0) {\n      cooldownModifier.timeRemaining = Math.max(0, cooldownModifier.timeRemaining - deltaTime);\n      \n      // If the effect has expired, reset to default\n      if (cooldownModifier.timeRemaining === 0) {\n        this.world.removeComponent(playerEntity, 'CooldownModifier');\n      }\n    }\n  }\n\n  /**\n   * Updates the player position based on input stored in the PlayerComponent\n   */\n  private updatePlayerMovement(playerEntity: Entity, deltaTime: number): void {\n    const player = this.world.getComponent<PlayerComponent>(playerEntity, 'Player');\n    const position = this.world.getComponent<PositionComponent>(playerEntity, 'Position');\n    const size = this.world.getComponent<SizeComponent>(playerEntity, 'Size');\n    \n    if (!player || !position || !size) return;\n    \n    // Handle left/right movement based on player input flags\n    if (player.isMovingLeft) {\n      position.x = Math.max(0, position.x - this.playerSpeed * deltaTime);\n    }\n    \n    if (player.isMovingRight) {\n      const maxX = this.canvasWidth - size.width;\n      position.x = Math.min(maxX, position.x + this.playerSpeed * deltaTime);\n    }\n  }\n\n  /**\n   * Creates a bullet entity when the player shoots\n   * \n   * This is a great example of entity creation with components in the ECS system\n   */\n  shoot(playerEntity: Entity): void {\n    const player = this.world.getComponent<PlayerComponent>(playerEntity, 'Player');\n    const position = this.world.getComponent<PositionComponent>(playerEntity, 'Position');\n    const size = this.world.getComponent<SizeComponent>(playerEntity, 'Size');\n    \n    if (!player || !position || !size) return; \n    \n    // Check if we're still in cooldown period\n    if (player.bulletCooldown > 0) return;\n    \n    // Create bullet\n    this.createBullet(\n      position.x + size.width * 0.5, \n      position.y, \n      10, \n      10\n    );\n    \n    // Get any active cooldown modifier\n    const cooldownModifier = this.world.getComponent<CooldownModifierComponent>(\n      playerEntity, \n      'CooldownModifier'\n    );\n    \n    // Apply cooldown modifier if one exists, otherwise use default cooldown\n    if (cooldownModifier) {\n      player.bulletCooldown = player.bulletCooldownMax * cooldownModifier.bulletCooldownMultiplier;\n    } else {\n      player.bulletCooldown = player.bulletCooldownMax;\n    }\n  }\n\n  /**\n   * Helper method to create a bullet entity with all necessary components\n   */\n  private createBullet(x: number, y: number, width: number, height: number): void {\n    // Create a new entity for the bullet\n    const bullet = this.world.createEntity();\n    \n    // Position component determines where the bullet appears\n    this.world.addComponent(bullet, new PositionComponent(x - width / 2, y));\n    \n    // Size component determines the bullet dimensions\n    this.world.addComponent(bullet, new SizeComponent(width, height));\n    \n    // Velocity component makes the bullet move upward\n    this.world.addComponent(bullet, new VelocityComponent(0, -500)); // Negative Y = upward\n    \n    // Render component gives the bullet its appearance\n    this.world.addComponent(bullet, new RenderComponent('yellow'));\n    \n    // Bullet component marks it as a bullet and stores bullet-specific data\n    this.world.addComponent(bullet, new BulletComponent(1, false));\n    \n    // Collision component allows the bullet to collide with enemies\n    this.world.addComponent(bullet, new CollisionComponent(true, 1, 'bullet'));\n  }\n}", "import { System } from \"../System\";\nimport {\n  PositionComponent,\n  SizeComponent,\n  VelocityComponent,\n  RenderComponent,\n  HealthComponent,\n  CollisionComponent,\n} from \"../components/CoreComponents\";\nimport {\n  EnemyComponent,\n  PowerupComponent,\n  type GameStateComponent,\n} from \"../components/GameComponents\";\n\n/**\n * SpawnSystem handles creating enemies and powerups at regular intervals\n */\nexport class SpawnSystem extends System {\n  private gameConfig: {\n    canvasWidth: number;\n    canvasHeight: number;\n    leftSideX: number;\n    rightSideX: number;\n    leftSideSpawnInterval: number;\n    rightSideSpawnInterval: number;\n  };\n\n  private lastEnemySpawnTime = 0;\n  private lastPowerupSpawnTime = 0;\n\n  private leftSideSpawnInterval: number;\n  private rightSideSpawnInterval: number;\n\n  constructor(gameConfig: {\n    canvasWidth: number;\n    canvasHeight: number;\n    leftSideX: number;\n    rightSideX: number;\n    leftSideSpawnInterval: number;\n    rightSideSpawnInterval: number;\n  }) {\n    super([\"GameState\"]); // Uses GameState component to check if game is active\n    this.gameConfig = gameConfig;\n\n    this.leftSideSpawnInterval = gameConfig.leftSideSpawnInterval;\n    this.rightSideSpawnInterval = gameConfig.rightSideSpawnInterval;\n  }\n\n  update(deltaTime: number): void {\n    // Find the game state entity\n    const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n    if (gameStateEntities.length === 0) return;\n\n    const gameStateEntity = gameStateEntities[0];\n    const gameState = this.world.getComponent<GameStateComponent>(gameStateEntity, \"GameState\");\n\n    if (!gameState || gameState.isPaused || gameState.isGameOver) return;\n\n    // Spawn enemies at intervals (using seconds)\n    this.lastEnemySpawnTime += deltaTime;\n    if (this.lastEnemySpawnTime > this.leftSideSpawnInterval) {\n      this.spawnEnemy();\n      this.lastEnemySpawnTime = 0;\n    }\n\n    // Spawn powerups at intervals (using seconds)\n    this.lastPowerupSpawnTime += deltaTime;\n    if (this.lastPowerupSpawnTime > this.rightSideSpawnInterval) {\n      // Randomly decide whether to spawn a powerup or a squisher\n      this.spawnPowerup();\n      this.lastPowerupSpawnTime = 0;\n    }\n  }\n\n  /**\n   * Create a new enemy entity\n   */\n  private spawnEnemy(): void {\n    const enemy = this.world.createEntity();\n\n    // Add components to the enemy\n    this.world.addComponent(\n      enemy,\n      new PositionComponent(\n        this.gameConfig.leftSideX - 15, // x (centered on left side)\n        -30 // y (above the screen)\n      )\n    );\n    this.world.addComponent(enemy, new SizeComponent(30, 30));\n    this.world.addComponent(enemy, new VelocityComponent(0, 50)); // Move downward\n    this.world.addComponent(enemy, new RenderComponent(\"red\"));\n    this.world.addComponent(enemy, new HealthComponent(1));\n    this.world.addComponent(enemy, new CollisionComponent(true, 0, \"enemy\"));\n    this.world.addComponent(enemy, new EnemyComponent(\"basic\", 10));\n  }\n\n  /**\n   * Create a new powerup entity\n   */\n  private spawnPowerup(): void {\n    const powerup = this.world.createEntity();\n\n    // Randomly determine the powerup type\n    const powerupTypes = [\"basic\", \"rapidFire\", \"superRapidFire\", \"normalizedFire\"];\n    const randomIndex = Math.floor(Math.random() * powerupTypes.length);\n    const powerupType = powerupTypes[randomIndex] as\n      | \"basic\"\n      | \"rapidFire\"\n      | \"superRapidFire\"\n      | \"normalizedFire\";\n\n    // Set color based on powerup type\n    let color = \"blue\";\n    switch (powerupType) {\n      case \"rapidFire\":\n        color = \"pink\";\n        break;\n      case \"superRapidFire\":\n        color = \"orange\";\n        break;\n      case \"normalizedFire\":\n        color = \"yellow\";\n        break;\n      default:\n        color = \"tan\";\n    }\n\n    // Add components to the powerup\n    this.world.addComponent(\n      powerup,\n      new PositionComponent(\n        this.gameConfig.rightSideX - 15, // x (centered on right side)\n        -30 // y (above the screen)\n      )\n    );\n    this.world.addComponent(powerup, new SizeComponent(30, 30));\n    this.world.addComponent(powerup, new VelocityComponent(0, 75)); // Move downward\n    this.world.addComponent(powerup, new RenderComponent(color));\n    this.world.addComponent(powerup, new HealthComponent(1));\n    this.world.addComponent(powerup, new CollisionComponent(true, 0, \"powerup\"));\n    this.world.addComponent(powerup, new PowerupComponent(powerupType, 1));\n  }\n}\n", "import { System } from '../System';\nimport type { HealthComponent } from '../components/CoreComponents';\nimport type { BulletComponent } from '../components/GameComponents';\n\n/**\n * CleanupSystem removes entities that are no longer needed\n * (dead enemies, hit bullets, etc)\n */\nexport class CleanupSystem extends System {\n  constructor() {\n    super(['Health', 'Position']);\n  }\n\n  update(deltaTime: number): void {\n    // Find and remove entities with zero health\n    const deadEntities = this.world.getEntitiesWith('Health').filter(entity => {\n      const health = this.world.getComponent<HealthComponent>(entity, 'Health');\n      return health && health.currentHealth <= 0;\n    });\n    \n    // Remove dead entities\n    for (const entity of deadEntities) {\n      this.world.removeEntity(entity);\n    }\n    \n    // Find and remove bullets that have hit something\n    const hitBullets = this.world.getEntitiesWith('Bullet').filter(entity => {\n      const bullet = this.world.getComponent<BulletComponent>(entity, 'Bullet');\n      return bullet?.hit;\n    });\n    \n    // Remove hit bullets\n    for (const entity of hitBullets) {\n      this.world.removeEntity(entity);\n    }\n  }\n}", "import { System } from \"../System\";\nimport type { Entity } from \"../Entity\";\nimport { CooldownModifierComponent, type PowerupComponent } from \"../components/GameComponents\";\n\n/**\n * PowerupSystem manages all powerup effects in the game\n * It tracks temporary powerups and removes them when they expire\n */\nexport class PowerupSystem extends System {\n  constructor() {\n    super([\"CooldownModifier\"]);\n  }\n\n  update(deltaTime: number): void {\n    // Get all entities with CooldownModifier component\n    const entitiesWithCooldown = this.world.getEntitiesWith(\"CooldownModifier\");\n\n    // Update each cooldown effect\n    for (const entity of entitiesWithCooldown) {\n      this.updateCooldownModifier(entity, deltaTime);\n    }\n  }\n\n  /**\n   * Updates a cooldown modifier and removes it if expired\n   */\n  private updateCooldownModifier(entity: Entity, deltaTime: number): void {\n    const cooldownModifier = this.world.getComponent<CooldownModifierComponent>(\n      entity,\n      \"CooldownModifier\"\n    );\n\n    if (!cooldownModifier) return;\n\n    // Only update temporary modifiers (ones with positive duration)\n    if (cooldownModifier.timeRemaining > 0) {\n      cooldownModifier.timeRemaining -= deltaTime;\n\n      // If the effect has expired, remove it\n      if (cooldownModifier.timeRemaining <= 0) {\n        this.world.removeComponent(entity, \"CooldownModifier\");\n      }\n    }\n  }\n\n  /**\n   * Apply a rapid fire powerup to an entity\n   * This is typically called when a player picks up a rapid fire powerup\n   */\n  applyRapidFirePowerup(entity: Entity, duration: number, multiplier = 0.5): void {\n    // Remove any existing cooldown modifier first\n    const existingModifier = this.world.getComponent<CooldownModifierComponent>(\n      entity,\n      \"CooldownModifier\"\n    );\n    if (existingModifier) {\n      if (multiplier < existingModifier.bulletCooldownMultiplier) {\n        this.world.removeComponent(entity, \"CooldownModifier\");\n      } else {\n        return; // Don't apply if existing modifier is stronger\n      }\n    }\n    // Add a new cooldown modifier component\n    this.world.addComponent(entity, new CooldownModifierComponent(multiplier, duration, duration));\n  }\n\n  /**\n   * Process a powerup collision and apply the appropriate effect\n   * This method should be called when a player collides with a powerup\n   */\n  processPowerup(playerEntity: Entity, powerupEntity: Entity): void {\n    const powerup = this.world.getComponent<PowerupComponent>(powerupEntity, \"Powerup\");\n\n    if (!powerup) return;\n    // Apply different effects based on powerup type\n    switch (powerup.powerupType) {\n      case \"superRapidFire\":\n        // Apply super rapid fire effect (75% faster shooting for 5 seconds)\n        this.applyRapidFirePowerup(playerEntity, 15, 0.25);\n        break;\n      case \"rapidFire\":\n        // Apply rapid fire effect (50% faster shooting for 5 seconds)\n        this.applyRapidFirePowerup(playerEntity, 15, 0.5);\n        break;\n      case \"normalizedFire\":\n        // Remove any existing cooldown effects to restore normal firing rate\n        if (this.world.getComponent(playerEntity, \"CooldownModifier\")) {\n          this.world.removeComponent(playerEntity, \"CooldownModifier\");\n        }\n        break;\n      default:\n        // Handle other powerup types as needed\n        console.warn(`Unhandled powerup type: ${powerup.powerupType}`);\n        break;\n    }\n  }\n}\n", "import { BackgroundComponent, type PathCommand } from \"../components/CoreComponents\";\n\n/**\n * BackgroundFactory utility for creating background components\n *\n * This factory handles the creation of various background components,\n * separating creation logic from the component data structure.\n *    \n * @example\n * // Add a decorative circular element\n * const circle = this.world.createEntity();\n * this.world.addComponent(\n *   circle, \n *   BackgroundFactory.createCustomPath(\n *     [\n *       { \n *         type: 'arc', \n *         x: this.config.canvasWidth / 2, \n *         y: this.config.canvasHeight - 150, \n *         radius: 50, \n *         startAngle: 0, \n *         endAngle: Math.PI * 2 \n *       }\n *     ],\n *     \"#ffe770\", \n *     2\n *   )\n * );\n * @example\n * // Right divider - using a wavy curved path\n * const rightBarrier = this.world.createEntity();\n * const rightX = (mainLines.rightBorder / 8) * 7;\n * const pathCommands = [{ type: 'moveTo', x: rightX - dividerRectWidth / 2, y: 0 }] as PathCommand[];\n *\n * // Create a wavy line using bezier curves\n * for (let y = 100; y < this.config.canvasHeight; y += 100) {\n *   const amplitude = dividerRectWidth / 2;\n *   pathCommands.push({\n *     type: 'bezierCurveTo',\n *     cp1x: rightX - dividerRectWidth / 2 - amplitude, \n *     cp1y: y - 50,\n *     cp2x: rightX - dividerRectWidth / 2 + amplitude, \n *     cp2y: y,\n *     x: rightX - dividerRectWidth / 2, \n *     y: y\n *   });\n * }\n * \n * // Complete the shape\n * pathCommands.push({ type: 'lineTo', x: rightX + dividerRectWidth / 2, y: this.config.canvasHeight });\n * pathCommands.push({ type: 'lineTo', x: rightX + dividerRectWidth / 2, y: 0 });\n * pathCommands.push({ type: 'closePath' });\n * this.world.addComponent(\n *  rightBarrier, \n *  BackgroundFactory.createCustomPath(\n *      pathCommands,\n *      \"#c5d5d9\", \n *      1\n *    )\n *  );\n */\nexport const BackgroundFactory = {\n  /**\n   * Create a rectangle background component\n   */\n  createRectangle(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    color = \"blue\",\n    zIndex = 0\n  ): BackgroundComponent {\n    return new BackgroundComponent(\"rectangle\", x, y, width, height, color, zIndex);\n  },\n\n  /**\n   * Create a polygon background component from a set of points\n   */\n  createPolygon(points: [number, number][], color = \"blue\", zIndex = 0): BackgroundComponent {\n    const pathCommands: PathCommand[] = [];\n\n    if (points.length > 0) {\n      // Move to the first point\n      pathCommands.push({ type: \"moveTo\", x: points[0][0], y: points[0][1] });\n\n      // Line to each subsequent point\n      for (let i = 1; i < points.length; i++) {\n        pathCommands.push({ type: \"lineTo\", x: points[i][0], y: points[i][1] });\n      }\n\n      // Close the path\n      pathCommands.push({ type: \"closePath\" });\n    }\n\n    return new BackgroundComponent(\n      \"polygon\",\n      points[0]?.[0] || 0,\n      points[0]?.[1] || 0,\n      0,\n      0,\n      color,\n      zIndex,\n      pathCommands\n    );\n  },\n\n  /**\n   * Create a custom path background component from a series of path commands\n   */\n  createCustomPath(\n    pathCommands: PathCommand[],\n    color = \"blue\",\n    zIndex = 0,\n    fillRule: \"nonzero\" | \"evenodd\" = \"nonzero\"\n  ): BackgroundComponent {\n    return new BackgroundComponent(\"custom\", 0, 0, 0, 0, color, zIndex, pathCommands, fillRule);\n  },\n};\n", "import { World } from \"./World\";\nimport { MovementSystem } from \"./systems/MovementSystem\";\nimport { RenderSystem } from \"./systems/RenderSystem\";\nimport { CollisionSystem } from \"./systems/CollisionSystem\";\nimport { PlayerSystem } from \"./systems/PlayerSystem\";\nimport { SpawnSystem } from \"./systems/SpawnSystem\";\nimport { CleanupSystem } from \"./systems/CleanupSystem\";\nimport { PowerupSystem } from \"./systems/PowerupSystem\";\nimport { BackgroundFactory } from \"./utils/BackgroundFactory\";\n\nimport {\n  PositionComponent,\n  SizeComponent,\n  RenderComponent,\n  HealthComponent,\n  CollisionComponent,\n  SpriteComponent,\n  type BackgroundComponent,\n  type PathCommand,\n} from \"./components/CoreComponents\";\nimport { PlayerComponent, TagComponent, GameStateComponent } from \"./components/GameComponents\";\n\n/**\n * Main Game class using ECS architecture\n *\n * This class initializes the ECS world, sets up systems,\n * creates the initial entities, and handles the game loop.\n */\nexport class Game {\n  // Core ECS world\n  private world: World;\n\n  // Game systems\n  private renderSystem: RenderSystem;\n  private playerSystem: PlayerSystem;\n  private powerupSystem: PowerupSystem;\n\n  // Game state\n  private gameInitialized = false;\n  private lastFrameTime = 0;\n  private animationFrameId: number | null = null;\n\n  // ========================= Configuration =========================\n  private config: ConstructorParameters<typeof SpawnSystem>[0] = {\n    canvasWidth: 800,\n    canvasHeight: 900,\n    leftSideX: 250,\n    rightSideX: 550,\n    leftSideSpawnInterval: 2,\n    rightSideSpawnInterval: 3,\n  };\n  // ========================= xxxxxxxxxxxxx =========================\n\n  /**\n   * Create a new game instance\n   */\n  constructor(private canvas: HTMLCanvasElement) {\n    // Get the canvas rendering context\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      throw new Error(\"Could not get canvas rendering context\");\n    }\n\n    // Set canvas dimensions\n    canvas.width = this.config.canvasWidth;\n    canvas.height = this.config.canvasHeight;\n\n    // Create the ECS world\n    this.world = new World();\n\n    // Create and add systems to the world\n    this.renderSystem = new RenderSystem(ctx);\n    this.world.addSystem(this.renderSystem);\n\n    this.world.addSystem(new MovementSystem());\n    this.world.addSystem(new CollisionSystem(this.config.canvasWidth, this.config.canvasHeight));\n\n    this.playerSystem = new PlayerSystem(this.config.canvasWidth, this.config.canvasHeight);\n    this.world.addSystem(this.playerSystem);\n\n    this.powerupSystem = new PowerupSystem();\n    this.world.addSystem(this.powerupSystem);\n\n    this.world.addSystem(new SpawnSystem(this.config));\n    this.world.addSystem(new CleanupSystem());\n\n    // Create background entities\n    this.createBackgroundElements();\n  }\n\n  /**\n   * Initialize the game\n   */\n  init(): void {\n    if (this.gameInitialized) return;\n    // Create game state entity\n    const gameStateEntity = this.world.createEntity();\n    this.world.addComponent(gameStateEntity, new GameStateComponent());\n    this.world.addComponent(gameStateEntity, new TagComponent(\"gameState\"));\n\n    // Create player entity\n    const player = this.world.createEntity();\n\n    // Add components to the player\n    this.world.addComponent(\n      player,\n      new PositionComponent(this.config.canvasWidth / 2 - 25, this.config.canvasHeight - 60)\n    );\n    this.world.addComponent(player, new SizeComponent(50, 50));\n    this.world.addComponent(player, new PlayerComponent());\n    this.world.addComponent(player, new HealthComponent(100));\n    this.world.addComponent(player, new CollisionComponent(true, 0, \"player\"));\n    this.world.addComponent(\n      player,\n      new SpriteComponent(\"assets/army-man-sprite.png\", 32, 32, 9, 16, 0, false, 1, false, 4)\n    );\n\n    // Set up input handlers\n    this.setupInputHandlers();\n    this.gameInitialized = true;\n  }\n\n  /**\n   * Create background elements using the ECS system\n   */\n  private createBackgroundElements(): void {\n    // Keep track of the main vertical lines we draw off of\n    const mainLines = {\n      leftBorder: 0, // (w / 8) * 0\n      leftSpawnLane: this.config.leftSideX, // (w / 8) * 2\n      midline: this.config.canvasWidth / 2, // (w / 8) * 4\n      rightSpawnLane: this.config.rightSideX, // (w / 8) * 6\n      rightBorder: this.config.canvasWidth, // (w / 8) * 8\n    };\n\n    const dividerRectWidth = 20;\n    const vanishingPoint: [number, number] = [this.config.canvasWidth / 2, -9999];\n    const leftDividerCenterLineX =\n      mainLines.midline - (mainLines.midline - mainLines.leftSpawnLane) * 2 ;\n    const rightDividerCenterLineX =\n      mainLines.midline + (mainLines.rightSpawnLane - mainLines.midline) * 2;\n\n    // water at very base\n    const backgroundWater = this.world.createEntity();\n    this.world.addComponent(\n      backgroundWater,\n      BackgroundFactory.createRectangle(\n        0,\n        0,\n        mainLines.rightBorder,\n        this.config.canvasHeight,\n        \"#42c8f5\",\n        -1\n      )\n    );\n\n    // road lane\n    const leftLane = this.world.createEntity();\n    this.world.addComponent(\n      leftLane,\n      BackgroundFactory.createPolygon(\n        [\n          vanishingPoint,\n          [leftDividerCenterLineX, this.config.canvasHeight],\n          [rightDividerCenterLineX, this.config.canvasHeight],\n        ],\n        \"#8b9699\",\n        0\n      )\n    );\n\n    // // Right lane - using rectangle\n    // const rightLane = this.world.createEntity();\n    // this.world.addComponent(\n    //   rightLane,\n    //   BackgroundFactory.createRectangle(\n    //     this.config.canvasWidth / 2,\n    //     0,\n    //     (mainLines.rightBorder / 8) * 3,\n    //     this.config.canvasHeight,\n    //     \"#8b9699\",\n    //     0\n    //   )\n    // );\n    // Left divider - using polygon for an angled shape\n    const leftBarrier = this.world.createEntity();\n    this.world.addComponent(\n      leftBarrier,\n      BackgroundFactory.createPolygon(\n        [\n          [(mainLines.rightBorder / 8) * 1 - dividerRectWidth / 2, 0],\n          [(mainLines.rightBorder / 8) * 1 - dividerRectWidth / 2 - 10, this.config.canvasHeight],\n          [(mainLines.rightBorder / 8) * 1 + dividerRectWidth / 2 - 10, this.config.canvasHeight],\n          [(mainLines.rightBorder / 8) * 1 + dividerRectWidth / 2, 0],\n        ],\n        \"#c5d5d9\",\n        1\n      )\n    );\n\n    // Middle divider - using a custom path with curves\n    const middleDivider = this.world.createEntity();\n    const midX = this.config.canvasWidth / 2;\n    const midY = this.config.canvasHeight - 250;\n\n    this.world.addComponent(\n      middleDivider,\n      BackgroundFactory.createCustomPath(\n        [\n          { type: \"moveTo\", x: midX - dividerRectWidth / 2, y: 0 },\n          { type: \"lineTo\", x: midX - dividerRectWidth / 2, y: midY - 50 },\n          {\n            type: \"quadraticCurveTo\",\n            cpx: midX - dividerRectWidth / 2,\n            cpy: midY,\n            x: midX,\n            y: midY,\n          },\n          {\n            type: \"quadraticCurveTo\",\n            cpx: midX + dividerRectWidth / 2,\n            cpy: midY,\n            x: midX + dividerRectWidth / 2,\n            y: midY - 50,\n          },\n          { type: \"lineTo\", x: midX + dividerRectWidth / 2, y: 0 },\n          { type: \"closePath\" },\n        ],\n        \"#c5d5d9\",\n        1\n      )\n    );\n\n    // // Right divider - using a wavy curved path\n    // const rightBarrier = this.world.createEntity();\n    // this.world.addComponent(\n    //   rightBarrier,\n    //   BackgroundFactory.createPolygon(\n    //     [\n    //       [(mainLines.rightBorder / 8) * 7 - dividerRectWidth / 2, 0],\n    //       [(mainLines.rightBorder / 8) * 7 - dividerRectWidth / 2 - 10, this.config.canvasHeight],\n    //       [(mainLines.rightBorder / 8) * 7 + dividerRectWidth / 2 - 10, this.config.canvasHeight],\n    //       [(mainLines.rightBorder / 8) * 7 + dividerRectWidth / 2, 0],\n    //     ],\n    //     \"#c5d5d9\",\n    //     1\n    //   )\n    // );\n\n    const rightBarrierPrism0 = this.world.createEntity();\n    this.world.addComponent(\n      rightBarrierPrism0,\n      BackgroundFactory.createPolygon(\n        // top\n        [\n          vanishingPoint,\n          [rightDividerCenterLineX - 10, this.config.canvasHeight],\n          [rightDividerCenterLineX + 10, this.config.canvasHeight],\n        ],\n        \"#FFF4C1FF\",\n        1\n      )\n    );\n    // Right divider\n    const rightBarrierPrism1 = this.world.createEntity();\n    this.world.addComponent(\n      rightBarrierPrism1,\n      BackgroundFactory.createPolygon(\n        [\n          vanishingPoint, // center point\n          [rightDividerCenterLineX - 10, this.config.canvasHeight],\n          [rightDividerCenterLineX - 20, this.config.canvasHeight],\n        ],\n        \"#94CB99FF\",\n        1\n      )\n    );\n  }\n\n  /**\n   * Start the game\n   */\n  start(): void {\n    if (!this.gameInitialized) {\n      this.init();\n    }\n\n    // Reset the game state\n    const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n    if (gameStateEntities.length > 0) {\n      const gameState = this.world.getComponent<GameStateComponent>(\n        gameStateEntities[0],\n        \"GameState\"\n      );\n      if (gameState) {\n        gameState.isPaused = false;\n        gameState.isGameOver = false;\n      }\n    }\n\n    // Start the game loop\n    this.lastFrameTime = performance.now();\n    this.gameLoop(this.lastFrameTime);\n  }\n\n  /**\n   * Pause the game\n   */\n  pause(): void {\n    const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n    if (gameStateEntities.length > 0) {\n      const gameState = this.world.getComponent<GameStateComponent>(\n        gameStateEntities[0],\n        \"GameState\"\n      );\n      if (gameState) {\n        gameState.isPaused = true;\n      }\n    }\n\n    // Cancel animation frame if it exists\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n\n    // Render one last frame to show the pause screen\n    const ctx = this.canvas.getContext(\"2d\");\n    if (ctx) {\n      // Clear the canvas\n      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // Continue to render the world (game objects will still be visible)\n      this.world.update(0); // Update with 0 delta to avoid movement\n\n      // Draw the pause text\n      ctx.fillStyle = \"black\";\n      ctx.font = \"48px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"PAUSED\", this.canvas.width / 2, this.canvas.height / 2);\n\n      ctx.font = \"24px Arial\";\n      ctx.fillText(\"Press P to resume\", this.canvas.width / 2, this.canvas.height / 2 + 50);\n    }\n  }\n\n  /**\n   * Resume the game\n   */\n  resume(): void {\n    const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n    if (gameStateEntities.length > 0) {\n      const gameState = this.world.getComponent<GameStateComponent>(\n        gameStateEntities[0],\n        \"GameState\"\n      );\n      if (gameState) {\n        gameState.isPaused = false;\n      }\n    }\n\n    // Reset player movement states to prevent actions from pause carrying over\n    const playerEntities = this.world.getEntitiesWith(\"Player\");\n    if (playerEntities.length > 0) {\n      const playerEntity = playerEntities[0];\n      const playerComponent = this.world.getComponent<PlayerComponent>(playerEntity, \"Player\");\n      if (playerComponent) {\n        // Reset movement flags\n        playerComponent.isMovingLeft = false;\n        playerComponent.isMovingRight = false;\n      }\n    }\n\n    if (this.animationFrameId === null) {\n      this.lastFrameTime = performance.now();\n      this.gameLoop(this.lastFrameTime);\n    }\n  }\n\n  /**\n   * Main game loop\n   */\n  private gameLoop(timestamp: number): void {\n    // Calculate delta time\n    const deltaTime = (timestamp - this.lastFrameTime) / 1000; // convert to seconds\n    this.lastFrameTime = timestamp;\n\n    // Clear the canvas\n    const ctx = this.canvas.getContext(\"2d\");\n    if (ctx) {\n      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n    // Update the ECS world\n    this.world.update(deltaTime);\n\n    // Check for game over\n    const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n    if (gameStateEntities.length > 0) {\n      const gameState = this.world.getComponent<GameStateComponent>(\n        gameStateEntities[0],\n        \"GameState\"\n      );\n      if (gameState?.isPaused) {\n        // Handle paused state (render pause screen)\n        if (ctx) {\n          ctx.fillStyle = \"black\";\n          ctx.font = \"48px Arial\";\n          ctx.textAlign = \"center\";\n          ctx.fillText(\"PAUSED\", this.canvas.width / 2, this.canvas.height / 2);\n\n          ctx.font = \"24px Arial\";\n          ctx.fillText(\"Press P to resume\", this.canvas.width / 2, this.canvas.height / 2 + 50);\n        }\n        return;\n      }\n      if (gameState?.isGameOver) {\n        // Handle game over (render game over screen)\n        if (ctx) {\n          ctx.fillStyle = \"black\";\n          ctx.font = \"48px Arial\";\n          ctx.textAlign = \"center\";\n          ctx.fillText(\"GAME OVER\", this.canvas.width / 2, this.canvas.height / 2);\n\n          ctx.font = \"24px Arial\";\n          ctx.fillText(\"Press R to restart\", this.canvas.width / 2, this.canvas.height / 2 + 50);\n        }\n      } else if (gameState && !gameState.isPaused) {\n        // Continue the game loop if not paused or game over\n        this.animationFrameId = requestAnimationFrame((time) => this.gameLoop(time));\n      }\n    }\n  }\n\n  /**\n   * Set up keyboard and mouse input handlers\n   */\n  private setupInputHandlers(): void {\n    // Keyboard input for movement\n    window.addEventListener(\"keydown\", (event) => {\n      // First check for pause toggle since this should work regardless of pause state\n      if (event.key === \"p\") {\n        const gsEntities = this.world.getEntitiesWith(\"GameState\");\n        if (gsEntities.length > 0) {\n          const gameState = this.world.getComponent<GameStateComponent>(gsEntities[0], \"GameState\");\n\n          if (gameState) {\n            if (gameState.isPaused) {\n              this.resume();\n            } else {\n              this.pause();\n            }\n          }\n        }\n        return;\n      }\n\n      // Check for restart on game over\n      if (event.key === \"r\") {\n        const restartGameStateEntities = this.world.getEntitiesWith(\"GameState\");\n        if (restartGameStateEntities.length > 0) {\n          const gameState = this.world.getComponent<GameStateComponent>(\n            restartGameStateEntities[0],\n            \"GameState\"\n          );\n\n          if (gameState?.isGameOver) {\n            // Reset the game\n            this.resetGame();\n            this.start();\n          }\n        }\n        return;\n      }\n\n      // Check if game is paused or over before processing other inputs\n      const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n      if (gameStateEntities.length > 0) {\n        const gameState = this.world.getComponent<GameStateComponent>(\n          gameStateEntities[0],\n          \"GameState\"\n        );\n        if (gameState?.isPaused || gameState?.isGameOver) {\n          return; // Don't process inputs while paused or game over\n        }\n      }\n\n      // Only process gameplay inputs if game is active\n      const playerEntities = this.world.getEntitiesWith(\"Player\");\n      if (playerEntities.length === 0) return;\n\n      const playerEntity = playerEntities[0];\n      const playerComponent = this.world.getComponent<PlayerComponent>(playerEntity, \"Player\");\n\n      if (playerComponent) {\n        switch (event.key) {\n          case \"ArrowLeft\":\n          case \"a\":\n            playerComponent.isMovingLeft = true;\n            break;\n          case \"ArrowRight\":\n          case \"d\":\n            playerComponent.isMovingRight = true;\n            break;\n          case \" \":\n          case \"w\":\n          case \"ArrowUp\":\n            // Shoot bullet\n            this.playerSystem.shoot(playerEntity);\n            break;\n        }\n      }\n    });\n\n    // Release key handlers\n    window.addEventListener(\"keyup\", (event) => {\n      // Check if game is paused before processing inputs\n      const gameStateEntities = this.world.getEntitiesWith(\"GameState\");\n      if (gameStateEntities.length > 0) {\n        const gameState = this.world.getComponent<GameStateComponent>(\n          gameStateEntities[0],\n          \"GameState\"\n        );\n        if (gameState?.isPaused || gameState?.isGameOver) {\n          return; // Don't process inputs while paused or game over\n        }\n      }\n\n      const playerEntities = this.world.getEntitiesWith(\"Player\");\n      if (playerEntities.length === 0) return;\n\n      const playerEntity = playerEntities[0];\n      const playerComponent = this.world.getComponent<PlayerComponent>(playerEntity, \"Player\");\n\n      if (playerComponent) {\n        switch (event.key) {\n          case \"ArrowLeft\":\n          case \"a\":\n            playerComponent.isMovingLeft = false;\n            break;\n          case \"ArrowRight\":\n          case \"d\":\n            playerComponent.isMovingRight = false;\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Reset the game state for a new game\n   */\n  resetGame(): void {\n    // Create a new world (this is simpler than trying to reset the existing one)\n    this.world = new World();\n\n    // Re-add systems to the world\n    const ctx = this.canvas.getContext(\"2d\");\n    if (!ctx) {\n      throw new Error(\"Could not get canvas rendering context\");\n    }\n\n    this.renderSystem = new RenderSystem(ctx);\n    this.world.addSystem(this.renderSystem);\n\n    this.world.addSystem(new MovementSystem());\n    this.world.addSystem(new CollisionSystem(this.config.canvasWidth, this.config.canvasHeight));\n\n    this.playerSystem = new PlayerSystem(this.config.canvasWidth, this.config.canvasHeight);\n    this.world.addSystem(this.playerSystem);\n\n    this.powerupSystem = new PowerupSystem();\n    this.world.addSystem(this.powerupSystem);\n\n    this.world.addSystem(new SpawnSystem(this.config));\n    this.world.addSystem(new CleanupSystem());\n\n    // Re-initialize the game\n    this.gameInitialized = false;\n    this.init();\n  }\n\n  /**\n   * Preload game assets\n   * This method can be called before starting the game to ensure all images are ready\n   */\n  async preloadAssets(imagePaths: string[]): Promise<void> {\n    if (imagePaths.length > 0) {\n      await this.renderSystem.preloadImages(imagePaths);\n    }\n  }\n}\n", "/**\n * Entry point for the Real Fake Ad Game\n * Refactored to use an Entity Component System (ECS) architecture\n */\nimport { Game } from './lib/ecs/Game';\n\n// Wait for DOM content to load\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Get canvas element\n  const canvas = document.getElementById('game-canvas') as HTMLCanvasElement;\n  \n  if (!canvas) {\n    console.error('Canvas element not found!');\n    return;\n  }\n  \n  // Create game instance using the ECS architecture\n  const game = new Game(canvas);\n  \n  // Initialize and start the game\n  game.init();\n  game.start();\n  \n  // Add event listener for the pause button\n  const pauseButton = document.getElementById('pause-button');\n  if (pauseButton) {\n    pauseButton.addEventListener('click', () => {\n      game.pause();\n    });\n  }\n  \n  // Add event listener for the resume button\n  const resumeButton = document.getElementById('resume-button');\n  if (resumeButton) {\n    resumeButton.addEventListener('click', () => {\n      game.resume();\n    });\n  }\n  \n  // Add event listener for the restart button\n  const restartButton = document.getElementById('restart-button');\n  if (restartButton) {\n    restartButton.addEventListener('click', () => {\n      game.resetGame();\n      game.start();\n    });\n  }\n});\n"],
  "mappings": "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",
  "names": []
}
